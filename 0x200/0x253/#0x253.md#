## 0x253 Assembly Language

Here we using `Intel` Synthax ,he is presented like this :

`operation <destination>,  <source>`

The destination and source values will either be a register, a memory address, or a value.
The operations are usually intuitive mnemonics: The mov
operation will move a value from the source to the destination, sub will subtract, inc will increment, and so forth.


Ex :
- (in gdb)
```asm
0x000055555555514e <+5>:	mov    rbp, rsp
0x0000555555555151 <+8>:	sub    rsp, $0x10
```
- (with gdb)
```asm
114e:	48 89 e5             	mov    rbp,rsp
1151:	48 83 ec 10          	sub    rsp,0x10
```

There are also operations that are used to control the flow of execution.
The cmp operation is used to compare values, and basically any operation beginning with j is used to jump to a different part of the code (depending on the result of the comparison).


```asm
0000000000001149 <main>:
    1149:	f3 0f 1e fa          	endbr64
    114d:	55                   	push   rbp
    114e:	48 89 e5             	mov    rbp,rsp
    1151:	48 83 ec 10          	sub    rsp,0x10
    1155:	c7 45 fc 00 00 00 00 	mov    DWORD PTR [rbp-0x4],0x0
    115c:	eb 13                	jmp    1171 <main+0x28>
    115e:	48 8d 05 9f 0e 00 00 	lea    rax,[rip+0xe9f]        # 2004 <_IO_stdin_used+0x4>
    1165:	48 89 c7             	mov    rdi,rax
    1168:	e8 e3 fe ff ff       	call   1050 <puts@plt>
    116d:	83 45 fc 01          	add    DWORD PTR [rbp-0x4],0x1
    1171:	83 7d fc 09          	cmp    DWORD PTR [rbp-0x4],0x9
    1175:	7e e7                	jle    115e <main+0x15>
    1177:	b8 00 00 00 00       	mov    eax,0x0
    117c:	c9                   	leave
    117d:	c3                   	ret
```


Here
```asm
    1151:       48 83 ec 10             sub    rsp,0x10
    1155:       c7 45 fc 00 00 00 00    mov    DWORD PTR [rbp-0x4],0x0
```
We can see that value "10" is substract of  `rsp` (storing result in `rsp`)  and value "0" it store in `rbp-0x4` 

After that we see the `jmp` to `1171 <main+0x28>`

```asm
1171:       83 7d fc 09             cmp    DWORD PTR [rbp-0x4],0x9
1175:       7e e7                   jle    115e <main+0x15>
```
who compare `rbp-0x4` (actually 0) with "9" and if this value is less or equal it jump `jle` (jump if less or equal ) to a `<main+0x15>`


### Exclu :

The -g flag can be used by the GCC compiler to include extra debugging information, which will give GDB access to the source code.

```bash
$ gcc -g firstprog.c
```

```bash
$ gdb -q ./a.out
Using host libthread_db library "/lib/libthread_db.so.1".
(gdb) list
1  #include <stdio.h>
2
3	int main()
4	{
5		int i;
6		for(i=0; i < 10; i++)
7		{
8			printf("Hello, world!\n");
9		}
10	}
(gdb) help set disassembly-flavor
Set the disassembly flavor.
The valid values are "att" and "intel", and the default value is "att". # the two possible assembly synthax 
(gdb) disassemble main
Dump of assembler code for function main:
   0x0000000000001149 <+0>:	endbr64
   0x000000000000114d <+4>:	push   rbp
   0x000000000000114e <+5>:	mov    rbp,rsp
   0x0000000000001151 <+8>:	sub    rsp,0x10
   0x0000000000001155 <+12>:	mov    DWORD PTR [rbp-0x4],0x0
   0x000000000000115c <+19>:	jmp    0x1171 <main+40>
   0x000000000000115e <+21>:	lea    rax,[rip+0xe9f]        # 0x2004
   0x0000000000001165 <+28>:	mov    rdi,rax
   0x0000000000001168 <+31>:	call   0x1050 <puts@plt>
   0x000000000000116d <+36>:	add    DWORD PTR [rbp-0x4],0x1
   0x0000000000001171 <+40>:	cmp    DWORD PTR [rbp-0x4],0x9
   0x0000000000001175 <+44>:	jle    0x115e <main+21>
   0x0000000000001177 <+46>:	mov    eax,0x0
   0x000000000000117c <+51>:	leave
   0x000000000000117d <+52>:	ret
End of assembler dump.

```
With `set disassembly-flavor intel` you can set `Intel` synthax by default or you can use this :

``bash
	echo "set disassembly-flavor intel" > ~/.gdbinit
```

We continue in file code

```asm
(gdb) break main
Breakpoint 1 at 0x1155: file files/file.c, line 6.
(gdb) run
Starting program: /home/sig/Capsule/theartofexploitation/0x200/0x253/files/file 

This GDB supports auto-downloading debuginfo from the following URLs:
  <https://debuginfod.ubuntu.com>
Enable debuginfod for this session? (y or [n]) n #because i offline ,)
Debuginfod has been disabled.
To make this setting permanent, add 'set debuginfod enabled off' to .gdbinit.
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".

Breakpoint 1, main () at files/file.c:6
6			for(i=0; i < 10; i++)
(gdb) info eip
Undefined info command: "eip".  Try "help info". 
(gdb) info register eip #not eip because we have in x64 
Invalid register `eip'
(gdb) info register rip
rip            0x555555555155      0x555555555155 <main+12>

```
Notice that EIP contains a memory address that points to an instruction in the main() function’s

The instructions before this (shown in italics) are collectively known as the function prologue and are generated by the compiler to set up memory for the rest of the main() function’s local variables. Part of the reason variables need to be declared in C is to aid the construction of this section of code. The debugger knows this part of the code is automatically generated and is smart enough to skip over it.


### Examine Memory with `x` (Not Twitter XD)

