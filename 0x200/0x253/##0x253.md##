## 0x253 Assembly Language

Here we using `Intel` Synthax ,he is presented like this :

`operation <destination>,  <source>`

The destination and source values will either be a register, a memory address, or a value.
The operations are usually intuitive mnemonics: The mov
operation will move a value from the source to the destination, sub will subtract, inc will increment, and so forth.


Ex :
- (in gdb)
```asm
0x000055555555514e <+5>:	mov    rbp, rsp
0x0000555555555151 <+8>:	sub    rsp, $0x10
```
- (with gdb)
```asm
114e:	48 89 e5             	mov    rbp,rsp
1151:	48 83 ec 10          	sub    rsp,0x10
```

There are also operations that are used to control the flow of execution.
The cmp operation is used to compare values, and basically any operation beginning with j is used to jump to a different part of the code (depending on the result of the comparison).


```asm
0000000000001149 <main>:
    1149:	f3 0f 1e fa          	endbr64
    114d:	55                   	push   rbp
    114e:	48 89 e5             	mov    rbp,rsp
    1151:	48 83 ec 10          	sub    rsp,0x10
    1155:	c7 45 fc 00 00 00 00 	mov    DWORD PTR [rbp-0x4],0x0
    115c:	eb 13                	jmp    1171 <main+0x28>
    115e:	48 8d 05 9f 0e 00 00 	lea    rax,[rip+0xe9f]        # 2004 <_IO_stdin_used+0x4>
    1165:	48 89 c7             	mov    rdi,rax
    1168:	e8 e3 fe ff ff       	call   1050 <puts@plt>
    116d:	83 45 fc 01          	add    DWORD PTR [rbp-0x4],0x1
    1171:	83 7d fc 09          	cmp    DWORD PTR [rbp-0x4],0x9
    1175:	7e e7                	jle    115e <main+0x15>
    1177:	b8 00 00 00 00       	mov    eax,0x0
    117c:	c9                   	leave
    117d:	c3                   	ret
```


Here
```asm
    1151:       48 83 ec 10             sub    rsp,0x10
    1155:       c7 45 fc 00 00 00 00    mov    DWORD PTR [rbp-0x4],0x0
```
We can see that value "10" is substract of  `rsp` (storing result in `rsp`)  and value "0" it store in `rbp-0x4` 

After that we see the `jmp` to `1171 <main+0x28>`

```asm
1171:       83 7d fc 09             cmp    DWORD PTR [rbp-0x4],0x9
1175:       7e e7                   jle    115e <main+0x15>
```
who compare `rbp-0x4` (actually 0) with "9" and if this value is less or equal it jump `jle` (jump if less or equal ) to a `<main+0x15>`


### Exclu :

The -g flag can be used by the GCC compiler to include extra debugging information, which will give GDB access to the source code.

```bash
$ gcc -g firstprog.c
```

```bash
$ gdb -q ./a.out
Using host libthread_db library "/lib/libthread_db.so.1".
(gdb) list
1  #include <stdio.h>
2
3	int main()
4	{
5		int i;
6		for(i=0; i < 10; i++)
7		{
8			printf("Hello, world!\n");
9		}
10	}
(gdb) help set disassembly-flavor
Set the disassembly flavor.
The valid values are "att" and "intel", and the default value is "att". # the two possible assembly synthax 
(gdb) disassemble main
Dump of assembler code for function main:
   0x0000000000001149 <+0>:	endbr64
   0x000000000000114d <+4>:	push   rbp
   0x000000000000114e <+5>:	mov    rbp,rsp
   0x0000000000001151 <+8>:	sub    rsp,0x10
   0x0000000000001155 <+12>:	mov    DWORD PTR [rbp-0x4],0x0
   0x000000000000115c <+19>:	jmp    0x1171 <main+40>
   0x000000000000115e <+21>:	lea    rax,[rip+0xe9f]        # 0x2004
   0x0000000000001165 <+28>:	mov    rdi,rax
   0x0000000000001168 <+31>:	call   0x1050 <puts@plt>
   0x000000000000116d <+36>:	add    DWORD PTR [rbp-0x4],0x1
   0x0000000000001171 <+40>:	cmp    DWORD PTR [rbp-0x4],0x9
   0x0000000000001175 <+44>:	jle    0x115e <main+21>
   0x0000000000001177 <+46>:	mov    eax,0x0
   0x000000000000117c <+51>:	leave
   0x000000000000117d <+52>:	ret
End of assembler dump.

```
With `set disassembly-flavor intel` you can set `Intel` synthax by default or you can use this :

``bash
	echo "set disassembly-flavor intel" > ~/.gdbinit
```

We continue in file code

```asm
(gdb) break main
Breakpoint 1 at 0x1155: file files/file.c, line 6.
(gdb) run
Starting program: /home/sig/Capsule/theartofexploitation/0x200/0x253/files/file 

This GDB supports auto-downloading debuginfo from the following URLs:
  <https://debuginfod.ubuntu.com>
Enable debuginfod for this session? (y or [n]) n #because i offline ,)
Debuginfod has been disabled.
To make this setting permanent, add 'set debuginfod enabled off' to .gdbinit.
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".

Breakpoint 1, main () at files/file.c:6
6			for(i=0; i < 10; i++)
(gdb) info eip
Undefined info command: "eip".  Try "help info". 
(gdb) info register eip #not eip because we have in x64 
Invalid register `eip'
(gdb) info register rip
rip            0x555555555155      0x555555555155 <main+12>

```
Notice that EIP contains a memory address that points to an instruction in the main() function’s

The instructions before this (shown in italics) are collectively known as the function prologue and are generated by the compiler to set up memory for the rest of the main() function’s local variables. Part of the reason variables need to be declared in C is to aid the construction of this section of code. The debugger knows this part of the code is automatically generated and is smart enough to skip over it.


### Examine Memory with `x` (Not Twitter XD)

The GDB debugger provides a direct method to examine memory, using the command x, which is short for examine.

The display format also uses a single-letter shorthand, which is optionally preceded by a count of how many items to examine. Some common format letters are as follows:

- o Display in octal.
- x Display in hexadecimal.
- u Display in unsigned, standard base-10 decimal.
- t Display in binary.

```asm
(gdb) i r rip
rip            0x555555555155      0x555555555155 <main+12>
(gdb) x/o 0x555555555155
0x555555555155 <main+12>:	077042707
(gdb) x/o $rip
0x555555555155 <main+12>:	077042707
(gdb) x/x 0x555555555155
0x555555555155 <main+12>:	0x00fc45c7
(gdb) x/x $rip
0x555555555155 <main+12>:	0x00fc45c7
(gdb) x/u 0x555555555155
0x555555555155 <main+12>:	16532935
(gdb) x/u $rip
0x555555555155 <main+12>:	16532935
(gdb) x/t 0x555555555155
0x555555555155 <main+12>:	00000000111111000100010111000111
(gdb) x/t $rip
0x555555555155 <main+12>:	00000000111111000100010111000111
```

You can use it with addresses value or $register, The memory the EIP register is pointing to can be examined by using the
address stored in EIP.

```asm
(gdb) x/12x $rip
0x555555555155 <main+12>:	0x00fc45c7	0xeb000000	0x058d4813	0x00000e9f
0x555555555165 <main+28>:	0xe8c78948	0xfffffee3	0x01fc4583	0x09fc7d83
0x555555555175 <main+44>:	0x00b8e77e	0xc9000000	0xf30000c3	0x48fa1e0f
```
The default size of a single unit is a four-byte unit called a `word`. The size of the display units for the `examine command` can bechanged by adding a size letter to the end of the format letter. The valid size letters are as follows:

- `b` A `single byte`
- `h` A `halfword`, which is `two bytes` in size
- `w` A `word`, which is `four bytes` in size
- `g` A `giant`, which is `eight bytes` in size

```asm
(gdb) x/8bx $rip
0x555555555155 <main+12>:	0xc7	0x45	0xfc	0x00	0x00	0x00	0x00	0xeb
(gdb) x/8hx $rip
0x555555555155 <main+12>:	0x45c7	0x00fc	0x0000	0xeb00	0x4813	0x058d	0x0e9f	0x0000
(gdb) x/8wx $rip
0x555555555155 <main+12>:	0x00fc45c7	0xeb000000	0x058d4813	0x00000e9f
0x555555555165 <main+28>:	0xe8c78948	0xfffffee3	0x01fc4583	0x09fc7d83
(gdb) x/8gx $rip
0x555555555155 <main+12>:	0xeb00000000fc45c7	0x00000e9f058d4813
0x555555555165 <main+28>:	0xfffffee3e8c78948	0x09fc7d8301fc4583
0x555555555175 <main+44>:	0xc900000000b8e77e	0x48fa1e0ff30000c3
0x555555555185 <_fini+5>:	0xc308c4834808ec83	0x0000000000000000
```
Notice that the first examine shows the first two bytes to be `0xc7` and `0x45`, but when a halfword is examined at the exact same memory address, the value `0x45c7` is shown, with the bytes reversed. This same byte-reversal effect can be seen when a full four-byte word is shown as `0x00fc45c7`, but when the first four bytes are shown byte by byte, they are in the order of `0xc7`,
`0x45`, `0xfc`, and `0x00` .
And if you remamber you can see that the 8bytes value is show by default

```asm
(gdb) x/x $rip
0x555555555155 <main+12>:	0xeb00000000fc45c7
```
This is because on the x86|x64 processor values are stored in little-endian
byte order, which means the least significant byte is stored first

Others Exemple

```asm
(gdb) x/x $rip
0x555555555155 <main+12>:	0x45c7
(gdb) x/4x $rip
0x555555555155 <main+12>:	0x45c7	0x00fc	0x0000	0xeb00
(gdb) x/4xb $rip
0x555555555155 <main+12>:	0xc7	0x45	0xfc	0x00
(gdb) x/4xh $rip
0x555555555155 <main+12>:	0x45c7	0x00fc	0x0000	0xeb00
(gdb) x/5x $rip
0x555555555155 <main+12>:	0x45c7	0x00fc	0x0000	0xeb00	0x4813
(gdb) x/5xh $rip
0x555555555155 <main+12>:	0x45c7	0x00fc	0x0000	0xeb00	0x4813
(gdb) x/5xb $rip
0x555555555155 <main+12>:	0xc7	0x45	0xfc	0x00	0x00
(gdb) x/4xh $rip
0x555555555155 <main+12>:	0x45c7	0x00fc	0x0000	0xeb00
(gdb) x/4xw $rip
0x555555555155 <main+12>:	0x00fc45c7	0xeb000000	0x058d4813	0x00000e9f
(gdb) x/4xg $rip
0x555555555155 <main+12>:	0xeb00000000fc45c7	0x00000e9f058d4813
0x555555555165 <main+28>:	0xfffffee3e8c78948	0x09fc7d8301fc4583

```

You can notice that :

- x/x  $rip : show by default `two bytes`
- x/4xb $rip : Show 4 bytes separate bytes by bytes (becauce `b`) is used . 
- x/4xh $rip : Show 4 bytes separate two bytes by two bytes (because `h`) is used . 
- x/4xw $rip : Show 4 bytes separates 4 bytes by 4 bytes (because `w`) is used .
- x/4xg $rip : Show 4 bytes separates 8 bytes by 8 bytes (because `g`) is used .


### Search About program info

```asm
(gdb) disassemble main
Dump of assembler code for function main:
   0x0000555555555149 <+0>:	endbr64
   0x000055555555514d <+4>:	push   rbp
   0x000055555555514e <+5>:	mov    rbp,rsp
   0x0000555555555151 <+8>:	sub    rsp,0x10
=> 0x0000555555555155 <+12>:	mov    DWORD PTR [rbp-0x4],0x0
   0x000055555555515c <+19>:	jmp    0x555555555171 <main+40>
   0x000055555555515e <+21>:	lea    rax,[rip+0xe9f]        # 0x555555556004
   0x0000555555555165 <+28>:	mov    rdi,rax
   0x0000555555555168 <+31>:	call   0x555555555050 <puts@plt>
   0x000055555555516d <+36>:	add    DWORD PTR [rbp-0x4],0x1
   0x0000555555555171 <+40>:	cmp    DWORD PTR [rbp-0x4],0x9
   0x0000555555555175 <+44>:	jle    0x55555555515e <main+21>
   0x0000555555555177 <+46>:	mov    eax,0x0
   0x000055555555517c <+51>:	leave
   0x000055555555517d <+52>:	ret
End of assembler dump.
(gdb) i r rip
rip            0x555555555155      0x555555555155 <main+12>

```

Here we can see that we are in this line `=> 0x0000555555555155 <+12>:    mov    DWORD PTR [rbp-0x4],0x0`
who affect `0` at `rbp-0x4` , if you observ `rip` value (current instruction) you can confirm that it synchronize with `=>`

```asm
(gdb) x/xb $rbp
0x7fffffffde30:	0x01
(gdb) x/xb $rbp - 4
0x7fffffffde2c:	0x00
```

With that you can see that value in `rbp - 4` is `0`

```asm
(gdb) x/i $rip
=> 0x555555555175 <main+44>:	jle    0x55555555515e <main+21>
(gdb) nexti
8				printf("Hello, world!\n");
(gdb) x/i $rip
=> 0x55555555515e <main+21>:	lea    rax,[rip+0xe9f]        # 0x555555556004
```

Here in comment we seen `0x555555556004`

```asm
(gdb) x/i 0x555555556004
0x555555556004:	rex.W
(gdb) x/6xb 0x555555556004
0x555555556004:	0x48	0x65	0x6c	0x6c	0x6f	0x2c
```
This char in ascii table can show anything

```asm
(gdb) x/6ub 0x555555556004
0x555555556004:	72	101	108	108	111	44
```