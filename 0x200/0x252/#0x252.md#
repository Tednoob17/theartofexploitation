## 0x252 The x86 Processor

(History)
{The 8086 CPU was the first x86 processor. It was developed and manufactured
by Intel, which later developed more advanced processors in the same
family: the 80186, 80286, 80386, and 80486. If you remember people talking
about 386 and 486 processors in the ’80s and ’90s, this is what they were
referring to.}

Here to see the registers we are use a debugger called GDB. Debuggers are used by program-
mers to step through compiled programs, examine program memory, and
view processor registers.

In default i think that `gdb` is installed in all GNU/Linux distro'

Often when i see any programmers or hackers use gdb i see that for run it they use `-q` option ,why ?

For use gdb you write this

```bash
$ gdb file  #file is a binary file. 
GNU gdb (Ubuntu 14.0.50.20230907-0ubuntu1) 14.0.50.20230907-git
Copyright (C) 2023 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<https://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from 0x200/0x250/files/file...
(gdb) 

```
Yes is long but when you write  `-q` option you can see the difference

```bash
$ gdb -q file 
Reading symbols from 0x200/0x250/files/file...
(gdb) 

```
It's so fine no ,)

Now we can use any command inside `gdb` tools like (break, info,run ...)


```bash
$ gdb -q 0x200/0x250/files/file 
Reading symbols from 0x200/0x250/files/file...
(gdb) break main #break is used to set a breakpoit in program

This GDB supports auto-downloading debuginfo from the following URLs:
  <https://debuginfod.ubuntu.com>
Enable debuginfod for this session? (y or [n]) n
Debuginfod has been disabled.
To make this setting permanent, add 'set debuginfod enabled off' to .gdbinit.
Breakpoint 1 at 0x1155: file firstprog.c, line 5.
(gdb) 

```
### Registers

```bash
gdb) info registers

rax            0x555555555149      93824992235849
rbx            0x7fffffffdfc8      140737488347080
rcx            0x555555557dc0      93824992247232
rdx            0x7fffffffdfd8      140737488347096
rsi            0x7fffffffdfc8      140737488347080
rdi            0x1                 1
rbp            0x7fffffffdeb0      0x7fffffffdeb0
rsp            0x7fffffffdea0      0x7fffffffdea0
r8             0x0                 0
r9             0x7ffff7fcb180      140737353920896
r10            0x7ffff7fc68e8      140737353902312
r11            0x7ffff7fe0cc0      140737354009792
r12            0x0                 0
r13            0x7fffffffdfd8      140737488347096
r14            0x555555557dc0      93824992247232
r15            0x7ffff7ffd000      140737354125312
rip            0x555555555155      0x555555555155 <main+12>
eflags         0x206               [ PF IF ]
cs             0x33                51
ss             0x2b                43
ds             0x0                 0
es             0x0                 0
fs             0x0                 0
gs             0x0                 0
fs_base        0x7ffff7fa9740      140737353783104
gs_base        0x0                 0

```

The first four registers : 
- RAX : Accumulator
- RCX : Counter
- RDX : Data
- RBX : Base
are known as general-purpose registers .

They are used for a variety of purposes, but they mainly
act as temporary variables for the CPU when it is executing machine instructions.

The second four registers :
- ESP : Stack Pointer
- EBP : Base Pointer
- ESI : Source Index
- EDI : Destination Index

The first two registers are called pointers because they store 32-bit
addresses, which essentially point to that location in memory.
These registers
are fairly important to program execution and memory management.

The last two registers are also technically pointers,which are commonly used to point to the source and destination when data
needs to be read from or written to. There are load and store instructions
that use these registers, but for the most part these registers can be thought of as just simple general-purpose registers.

The EIP register is the Instruction Pointer register, which points to the
current instruction the processor is reading.
Like a child pointing his finger
at each word as he reads, the processor reads each instruction using the EIP
register as its finger. Naturally, this register is quite important and will be used
a lot while debugging. Currently, it points to a memory address at0x555555555155