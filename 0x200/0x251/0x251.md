## 0x251 The Bigger Picture

The binary a.out’s instructions are
written in machine language, an elementary language the CPU can under-
stand. Compilers are designed to translate the language of C code into machine
language for a variety of processor architectures. In this case, the processor
is in a family that uses the x86 architecture. There are also Sparc processor
architectures (used in Sun Workstations) and the PowerPC processor arch-
itecture (used in pre-Intel Macs).

Each architecture has a different machine
language, so the compiler acts as a middle ground—translating C code into
machine language for the target architecture.

Basely in "The Art of Exploitation" CPU Architecture used is `x86` but in my case i use a next gen PC in `x64`

```bash
xtrm% objdump -D -M intel files/file |grep -A 20 main.:
0000000000001149 <main>:
    1149:	f3 0f 1e fa          	endbr64
    114d:	55                   	push   rbp
    114e:	48 89 e5             	mov    rbp,rsp
    1151:	48 83 ec 10          	sub    rsp,0x10
    1155:	c7 45 fc 00 00 00 00 	mov    DWORD PTR [rbp-0x4],0x0
    115c:	eb 13                	jmp    1171 <main+0x28>
    115e:	48 8d 05 9f 0e 00 00 	lea    rax,[rip+0xe9f]        # 2004 <_IO_stdin_used+0x4>
    1165:	48 89 c7             	mov    rdi,rax
    1168:	e8 e3 fe ff ff       	call   1050 <puts@plt>
    116d:	83 45 fc 01          	add    DWORD PTR [rbp-0x4],0x1
    1171:	83 7d fc 09          	cmp    DWORD PTR [rbp-0x4],0x9
    1175:	7e e7                	jle    115e <main+0x15>
    1177:	b8 00 00 00 00       	mov    eax,0x0
    117c:	c9                   	leave
    117d:	c3                   	ret

```
If you be attentive you can remark that here it's `x64` `registers` who are used .
The `32-bit processors` have `2^32` (or 4,294,967,296) possible `addresses`, while the `64-bit` ones have
2^64 (1.84467441 × 10^19) possible `addresses`.

The hexadecimal `bytes` in the middle of the listing above are the machine
language instructions for the `x86 processor`. Of course, these hexadecimal values
are only representations of the `bytes of binary` `1`s and `0`s the `CPU` can
understand. But since `0101010110001001111001011000001111101100111100001 . . .`
isn’t very useful to anything other than the `processor`, the machine code is
displayed as `hexadecimal bytes` and each `instruction` is put on its own line,
like splitting a paragraph into sentences.

Come to think of it, the hexadecimal `bytes` really aren’t very useful them-
selves, either—that’s where assembly language comes in. The instructions on
the far right are in assembly language. Assembly language is really just a collection of `mnemonics` for the corresponding machine language instructions.
The instruction `ret` is far easier to `remember` and make sense of than `0xc3` or `11000011` (Always x86,x64)
